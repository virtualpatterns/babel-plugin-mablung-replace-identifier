{"version":3,"sources":["../../../source/test/library/visitor-multiple.test.js"],"names":[],"mappings":"AAAA,SAAS,aAAa,IAAI,aAA1B,QAA+C,QAA/C;AACA,OAAO,KAAP,MAAkB,aAAlB;AACA,OAAO,IAAP,MAAiB,KAAjB;;AAEA,MAAM,OAAO,GAAG,aAAa,CAAC,MAAM,CAAC,IAAP,CAAY,GAAb,CAA7B;;AAEA,IAAI,CAAC,UAAL,CAAgB,CAAC,IAAD,KAAU;;AAExB,EAAA,IAAI,CAAC,OAAL,CAAa,MAAb,GAAsB,wDAAtB;AACA,EAAA,IAAI,CAAC,OAAL,CAAa,MAAb,GAAsB;AACpB,eAAW;AACT;AACE,IAAA,OAAO,CAAC,OAAR,CAAgB,iBAAhB,CADF;AAEE;AACE,cAAQ;AACN;AACE,qBAAa,YADf;AAEE,uBAAe,qDAFjB;AAGE,wBAAgB;AACd,qBAAW,CAAE,YAAF,CADG;AAEd,wBAAc,QAFA,EAHlB;;AAOE,qBAAa;AACX;AACE,kBAAQ,SADV;AAEE,oBAAU,KAFZ;AAGE,oBAAU;AACR,wBAAY,KADJ,EAHZ,EADW,CAPf,EADM;;;;;AAkBN;AACE,qBAAa,WADf;AAEE,uBAAe,uCAFjB;AAGE,wBAAgB;AACd,qBAAW,CAAE,YAAF,CADG;AAEd,wBAAc,QAFA,EAHlB;;AAOE,qBAAa;AACX;AACE,kBAAQ,OADV;AAEE,kBAAQ,eAFV;AAGE,oBAAU,QAHZ,EADW,CAPf,EAlBM,CADV,EAFF,CADS,CADS,EAAtB;;;;;;;;;;AA4CD,CA/CD;;AAiDA,IAAI,CAAC,0HAAD,EAA6H,OAAO,IAAP,KAAgB;;AAE/I,MAAI,EAAE,IAAI,EAAE,aAAR,KAA0B,MAAM,KAAK,CAAC,cAAN,CAAqB,IAAI,CAAC,OAAL,CAAa,MAAlC,EAA0C,IAAI,CAAC,OAAL,CAAa,MAAvD,CAApC;AACA,MAAI,eAAe,GAAG,iMAAtB;;AAEA;AACA,EAAA,IAAI,CAAC,EAAL,CAAQ,aAAR,EAAuB,eAAvB;;AAED,CARG,CAAJ","file":"visitor-multiple.test.js","sourcesContent":["import { createRequire as CreateRequire } from 'module'\nimport Babel from '@babel/core'\nimport Test from 'ava'\n\nconst Require = CreateRequire(import.meta.url)\n\nTest.beforeEach((test) => {\n\n  test.context.codeIn = 'const FilePath = __filePath\\nconst Require = __require'\n  test.context.option = { \n    'plugins': [ \n      [\n        Require.resolve('../../index.cjs'),\n        {\n          'rule': [\n            {\n              'searchFor': '__filePath',\n              'replaceWith': '__importIdentifier_0.fileURLToPath(import.meta.url)',\n              'parserOption': { \n                'plugins': [ 'importMeta' ], \n                'sourceType': 'module' \n              },\n              'addImport': [\n                {\n                  'type': 'default',\n                  'source': 'url',\n                  'option': {\n                    'nameHint': 'URL'\n                  }\n                }\n              ]\n            },\n            {\n              'searchFor': '__require',\n              'replaceWith': '__importIdentifier_0(import.meta.url)',\n              'parserOption': { \n                'plugins': [ 'importMeta' ], \n                'sourceType': 'module' \n              },\n              'addImport': [\n                {\n                  'type': 'named',\n                  'name': 'createRequire',\n                  'source': 'module'\n                }\n              ]\n            }\n          ]\n        }      \n      ]\n    ]\n  }\n  \n})\n\nTest('rule.replaceWith = \\'__importIdentifier_0.fileURLToPath(import.meta.url)\\' and \\'__importIdentifier_0(import.meta.url)\\'', async (test) => {\n\n  let { code: actualCodeOut } = await Babel.transformAsync(test.context.codeIn, test.context.option)\n  let expectedCodeOut = 'import { createRequire as _createRequire } from \"module\";\\nimport _URL from \"url\";\\n\\nconst FilePath = _URL.fileURLToPath(import.meta.url);\\n\\nconst Require = _createRequire(import.meta.url);'\n\n  // test.log(actualCodeOut)\n  test.is(actualCodeOut, expectedCodeOut)\n\n})\n"]}